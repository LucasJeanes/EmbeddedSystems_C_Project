/*
 * userApp.c
 *
 *  Created on: Created on: Oct 18, 2024
 *      Author: Niall.OKeeffe@atu.ie
 */

#include "main.h"
#include "userApp.h"
#include "FreeRTOS.h"

#include "task.h"
#include "semphr.h"
#include "queue.h"
#include "event_groups.h"
#include "timers.h"
#include <stdint.h>

#include "hsensor.h"
#include "tsensor.h"
#include "psensor.h"

#define TEMP_Bit (1 << 0)
#define PRESSURE_Bit (1 << 1)
#define HUMIDITY_Bit (1 << 2)
#define SYNC_Bits (TEMP_Bit | PRESSURE_Bit | HUMIDITY_Bit)

//Peripheral Handles
extern UART_HandleTypeDef huart1;
extern TIM_HandleTypeDef htim6;

//Network variables
extern int network_wr(Network* n, unsigned char* buffer, int len, int timeout_ms);
extern int network_rd(Network* n, unsigned char* buffer, int len, int timeout_ms);
extern int net_if_init(void * if_ctxt);
extern int net_if_deinit(void * if_ctxt);
extern int net_if_reinit(void * if_ctxt);
extern int wifi_net_if_init(void * if_ctxt);

//RTOS task function prototypes and object declarations
static void RTC_Task(void * pvParameters);
static void initTask(void * pvParameters);

static void sensorTask(void * pvParameters);
static void publishTask(void * pvParameters);
static void sensorControllerTask(void * pvParameters);


SemaphoreHandle_t publishSemaphore = NULL, oneSecondSemaphore = NULL, sensorSemaphore = NULL;
EventGroupHandle_t sensorEventGroup = NULL;
TaskHandle_t sensorControllerHandle = NULL, sensorTaskHandle = NULL;
QueueHandle_t sensorQueue;
EventBits_t sensorBits;
TimerHandle_t autoPublishTimer;

uint8_t RTC_TaskRunning = 0, initCycleFinished = 0, autopublishFlag = 0;
uint8_t toggleTemp = 0, togglePressure = 0, toggleHumidity = 0;

uint8_t timeDisplay = 0;
net_hnd_t hnet;
Network network;
MQTTPacket_connectData options = MQTTPacket_connectData_initializer;
net_sockhnd_t socket;
MQTTClient client;

typedef struct {
    float temperature;
    uint16_t pressure;
    uint16_t humidity;
} SensorData;

typedef enum {
    NOTIFY_TEMP = 1 << 0,      // 0x01
    NOTIFY_PRESSURE = 1 << 1,  // 0x02
    NOTIFY_HUMIDITY = 1 << 2   // 0x04
} SensorNotification;

typedef struct {
  char *HostName;
  char *HostPort;
  char *ConnSecurity;
  char *MQClientId;
  char *MQUserName;
  char *MQUserPwd;
#ifdef LITMUS_LOOP
  char *LoopTopicId;
#endif
} device_config_t;


/*--------------------------------------------------------------------
 * EXTI interrupt handler callback function
 * Will give a semaphore when the user button is pressed
 --------------------------------------------------------------------*/
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	BaseType_t xHigherPriorityTaskWoken;
	switch (GPIO_Pin)
	{
	case (GPIO_PIN_1):	//IRQ generated by WiFi module
		{
		SPI_WIFI_ISR();
		break;
		}

	case (BUTTON_EXTI13_Pin) :	//IRQ generated by user button
		{
		printf("User button pressed\r\n\n");
		xHigherPriorityTaskWoken = pdFALSE;
		xSemaphoreGiveFromISR(publishSemaphore, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
		}

	default:
	{
		break;
	}
	}
}

void TIM6_Handler() {
	if(initCycleFinished > 0) {
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		printf("Sensor timer triggered. Giving sensor semaphore...\r\n");
		xSemaphoreGiveFromISR(sensorSemaphore, &xHigherPriorityTaskWoken);
        if (autopublishFlag) {
        	xTimerStartFromISR(autoPublishTimer, &xHigherPriorityTaskWoken);
        }
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void AutoPublishTimerCallback(TimerHandle_t xTimer) {
    printf("Auto-publish timer triggered!\r\n");
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	xSemaphoreGiveFromISR(publishSemaphore, &xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/*--------------------------------------------------------------------
 * RTC timer event interrupt handler callback function
 * Runs every second and gives a semaphore if the RTC task is running
 --------------------------------------------------------------------*/
void HAL_RTCEx_WakeUpTimerEventCallback (RTC_HandleTypeDef * hrtc) {
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if(RTC_TaskRunning){
		xHigherPriorityTaskWoken = pdFALSE;
		xSemaphoreGiveFromISR(oneSecondSemaphore, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

/*--------------------------------------------------------------------------
 * Subscribe message callback function
 * Called every time a publish message is received from a subscribed topic
 --------------------------------------------------------------------------*/
void subscribeMessageHandler(MessageData* data)
{
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	static char mqtt_msg[MQTT_MSG_BUFFER_SIZE], mqtt_topic[MQTT_TOPIC_BUFFER_SIZE];
	snprintf(mqtt_msg, data->message->payloadlen+1, "%s", (char *)data->message->payload);
	snprintf(mqtt_topic, data->topicName->lenstring.len+1, "%s", data->topicName->lenstring.data);
	//printf("\r\nPublished message from MQTT broker\r\n");
	//printf("Topic: %s, Payload: %s\r\n\n", mqtt_topic, mqtt_msg);

	//Change the string parsing to match your Ubidots settings
	if(strstr(mqtt_topic, "rtos_grpa/ledswitch-1")) {	//check topic
		if(strstr(mqtt_msg, "\"value\": 1.0")) {	//check data published from topic
			HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
		}
		else {
			HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
		}
	}
	if(strstr(mqtt_topic, "rtos_grpa/autopublish")) {	//check topic
		if(strstr(mqtt_msg, "\"value\": 1.0")) {	//check data published from topic
			printf("Auto publish [ENABLE]\r\n\n");
			autopublishFlag = 1;
		}
		else {
			printf("Auto publish [DISABLED]\r\n\n");
			autopublishFlag = 0;
		}
	}
	if(strstr(mqtt_topic, "rtos_grpa/tempsw")) {	//TEMPERATURE SENSOR TOGGLE
		if(strstr(mqtt_msg, "\"value\": 1.0")) {
			printf("Temperature subscribe [ENABLE]\r\n");
			xEventGroupSetBitsFromISR(sensorEventGroup, TEMP_Bit, &xHigherPriorityTaskWoken);
		}
		else {
			printf("Temperature subscribe [DISABLED]\r\n");
			xEventGroupClearBitsFromISR(sensorEventGroup, TEMP_Bit);
		}
	}
	if(strstr(mqtt_topic, "rtos_grpa/humiditysw")) {	//HUMIDITY SENSOR TOGGLE
		if(strstr(mqtt_msg, "\"value\": 1.0")) {	//check data published from topic
			printf("Humidity subscribe [ENABLE]\r\n");
			xEventGroupSetBitsFromISR(sensorEventGroup, HUMIDITY_Bit, &xHigherPriorityTaskWoken);
		}
		else {
			printf("Humidity subscribe [DISABLED]\r\n");
			xEventGroupClearBitsFromISR(sensorEventGroup, HUMIDITY_Bit);
		}
	}
	if(strstr(mqtt_topic, "rtos_grpa/pressuresw")) {	//PRESSURE SENSOR TOGGLE
		if(strstr(mqtt_msg, "\"value\": 1.0")) {	//check data published from topic
			printf("Pressure subscribe [ENABLE]\r\n");
			xEventGroupSetBitsFromISR(sensorEventGroup, PRESSURE_Bit, &xHigherPriorityTaskWoken);
		}
		else {
			printf("Pressure subscribe [DISABLED]\r\n");
			xEventGroupClearBitsFromISR(sensorEventGroup, PRESSURE_Bit);
		}
	}
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

static void sensorControllerTask(void * pvParameters) {
	uint32_t sensorsEnabled = 0;
	while(1) {
		if(xSemaphoreTake(sensorSemaphore, portMAX_DELAY) == pdTRUE) {
			sensorBits = xEventGroupWaitBits(sensorEventGroup, SYNC_Bits, pdFALSE, pdFALSE, portMAX_DELAY);
			if(sensorBits & TEMP_Bit) {
			    printf("Sensor controller [TEMP] ON\r\n");
			    sensorsEnabled |= NOTIFY_TEMP; // Set the TEMP notification bit
			} else {
			    printf("Sensor controller [TEMP] OFF\r\n");
			    sensorsEnabled &= ~NOTIFY_TEMP; // Clear the TEMP notification bit(NOT + AND = 0)
			}
			if(sensorBits & PRESSURE_Bit) { // Read pressure
			    printf("Sensor controller [PRESSURE] ON\r\n");
			    sensorsEnabled |= NOTIFY_PRESSURE; // Set the PRESSURE notification bit
			} else {
			    printf("Sensor controller [PRESSURE] OFF\r\n");
			    sensorsEnabled &= ~NOTIFY_PRESSURE; // Clear the PRESSURE notification bit(NOT + AND = 0)
			}
			if(sensorBits & HUMIDITY_Bit) { // Read humidity
			    printf("Sensor controller [HUMIDITY] ON\r\n");
			    sensorsEnabled |= NOTIFY_HUMIDITY; // Set the HUMIDITY notification bit
			} else {
			    printf("Sensor controller [HUMIDITY] OFF\r\n");
			    sensorsEnabled &= ~NOTIFY_HUMIDITY; // Clear the HUMIDITY notification bit(NOT + AND = 0)
			}
			if(sensorsEnabled != 0) {
				xTaskNotify(sensorTaskHandle, sensorsEnabled, eSetBits);
			}
		}
	}
}

static void sensorTask(void * pvParameters) {
	SensorData data;
	uint32_t ulsensorsEnabled = 0;

	while(1) {
        if (xTaskNotifyWait(0, 0xFFFFFFFF, &ulsensorsEnabled, portMAX_DELAY) == pdTRUE) {
            if (ulsensorsEnabled & NOTIFY_TEMP) {
            	data.temperature = BSP_TSENSOR_ReadTemp();
            	printf("Reading temp..\r\n");
            } else
            	{
					printf("Temperature sensor disabled...\r\n");
					data.temperature = -999.0f; //sentinel value
            	}

            if (ulsensorsEnabled & NOTIFY_PRESSURE) {
				data.pressure = BSP_PSENSOR_ReadPressure();
				printf("Reading pressure..\r\n");
            } else
				{
					printf("Pressure sensor disabled...\r\n");
					data.pressure = UINT16_MAX; //sentinel value
				}

            if (ulsensorsEnabled & NOTIFY_HUMIDITY) {
                data.humidity = (uint16_t)BSP_HSENSOR_ReadHumidity();
				printf("Reading humidity..\r\n");
            } else
				{
					printf("Humidity sensor disabled...\r\n");
					data.humidity = UINT16_MAX; //sentinel value
				}
        }
            if (xQueueSend(sensorQueue, &data, 0) != pdPASS) {
                printf("Queue is full, overwriting old sensor data...\r\n");
				if (xQueueOverwrite(sensorQueue, &data) != pdPASS) {
					printf("[ERROR] Failed to overwrite data in queue\r\n");
				}
            }
            printf("Sent sensor data to queue\r\n\n");
            //ulsensorsEnabled = 0;
		}
		vTaskDelay(pdMS_TO_TICKS(100));
	}
//}

static void publishTask(void * pvParameters) {
		MQTTMessage mqmsg;
		char tempStr[20];
		char pressureStr[20];
		char humidityStr[20];
		char publishPayload[100] = "{";
		uint8_t payloadLength = 1;	//include opening JSON bracket
	    SensorData receivedData;

		while(1) {
			if(xSemaphoreTake(publishSemaphore, 0) == pdTRUE) {

		        if (xQueueReceive(sensorQueue, &receivedData, 0) == pdPASS) {
		        	printf("Received sensor data from queue!\r\n\n");
		        	if (receivedData.temperature != -999.0f) {
		        	    snprintf(tempStr, sizeof(tempStr), "\"temperature\":%.1f", receivedData.temperature);
		        	    strcat(publishPayload, tempStr);
		        	    payloadLength += 1;
		        	}
		        	if (receivedData.pressure != UINT16_MAX) {
		        	    if (payloadLength > 1) strcat(publishPayload, ",");
		        	    snprintf(pressureStr, sizeof(pressureStr), "\"pressure\":%d", receivedData.pressure);
		        	    strcat(publishPayload, pressureStr);
		        	    payloadLength += 1;
		        	}
		        	if (receivedData.humidity != UINT16_MAX) {
		        	    if (payloadLength > 1) strcat(publishPayload, ",");
		        	    snprintf(humidityStr, sizeof(humidityStr), "\"humidity\":%d", receivedData.humidity);
		        	    strcat(publishPayload, humidityStr);
		        	}
		        	strcat(publishPayload, "}");

				memset(&mqmsg, 0, sizeof(MQTTMessage));
				mqmsg.qos = QOS0;
				mqmsg.payload = (char *) publishPayload;
				mqmsg.payloadlen = strlen(publishPayload);

				//change the device api label to match your Ubidots configuration
				MQTTPublish(&client, "/v1.6/devices/rtos_grpa", &mqmsg);
				printf("Publishing data: %s\r\n\n", publishPayload);

				//Reset variables
				publishPayload[0] = '{';
				publishPayload[1] = '\0'; //Null character i.e. end of string
				payloadLength = 1;
		        }
			}
			vTaskDelay(pdMS_TO_TICKS(100));
		}
	}
/*-----------------------------------------------------------
 * Task to print the date and time when a semaphore is taken
-------------------------------------------------------------*/
static void RTC_Task(void * pvParameters) {
	RTC_TimeTypeDef sTime;
	RTC_DateTypeDef sDate;
	char timeBuffer[40];

	RTC_TaskRunning = 1;	//flag set to allow RTC event interrupt handler callback to send semaphores

	while(1) {
		MQTTYield(&client, 200);	//Yield needed to allow check for received published messages from subscribed topics

		if(xSemaphoreTake(oneSecondSemaphore, 0) == pdTRUE) {
			timeDisplay = 0;
			HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
			HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
			sprintf(timeBuffer, "%02d/%02d/%02d %02d:%02d:%02d\r\n", sDate.Date, sDate.Month, sDate.Year, sTime.Hours+1, sTime.Minutes, sTime.Seconds);
			printf("%s", timeBuffer);
		}
		vTaskDelay(pdMS_TO_TICKS(100));
	}
}

/*--------------------------------------
 * Initialisation Task
 * 1. Connects to ubidots MQTT broker
 * 2. Initialises temperature sensor
 * 3. Creates semaphores
 * 4. Creates temperature and RTC tasks
 * 5. Subscribes to LED_Control variable
 * 6. Task delates itself
 ----------------------------------------*/
static void initTask(void * pvParameters) {
	uint32_t ret;
	printf("Starting Init Task\r\n");

	while(1) {
		HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
		brokerConnect(&client);	//connect to WiFi access point and then to MQTT broker

		//*****Initialize semaphores*******//
		publishSemaphore = xSemaphoreCreateBinary();
		vQueueAddToRegistry(publishSemaphore, "Publish Semaphore");
		oneSecondSemaphore = xSemaphoreCreateBinary();
		vQueueAddToRegistry(oneSecondSemaphore, "RTC Semaphore");
		sensorSemaphore = xSemaphoreCreateBinary();
		vQueueAddToRegistry(sensorSemaphore, "Sensor Semaphore");
		//*****Initialize auto-publish software timer*******//
		autoPublishTimer = xTimerCreate("AutoPublishTimer", pdMS_TO_TICKS(4000), pdFALSE, (void *)0, AutoPublishTimerCallback);
	    if (autoPublishTimer == NULL) {
	        printf("Failed to create auto-publish timer\r\n");
	    } else {
	        printf("Auto-publish timer created\r\n");
	    }
		//*****Initialize sensor data queue*******//
		sensorQueue = xQueueCreate(1, sizeof(SensorData));
		if (sensorQueue == NULL) {
		    printf("Failed to create sensor queue\r\n");
		} else {
		    printf("Sensor queue created\r\n");
		}

		//*****Initialize sensor event group*******//
		sensorEventGroup = xEventGroupCreate();
		if (sensorEventGroup == NULL) {
		    printf("Failed to create sensor event group\r\n");
		} else {
		    printf("Sensor event group created\r\n");
		}

		//*****Initialize tasks*******//
		if(xTaskCreate(sensorControllerTask, "SensorController Task", 500, NULL, configMAX_PRIORITIES - 5, &sensorControllerHandle) == pdTRUE) {
			printf("SensorController task created\n\r");
		}
		else {
			printf("Could not create SensorController task\n\r");
		}
		if(xTaskCreate(publishTask, "Publish Task", 500, NULL, configMAX_PRIORITIES - 4, NULL) == pdTRUE) {
			printf("Publish task created\n\r");
		}
		else {
			printf("Could not create Publish task\n\r");
		}
		if(xTaskCreate(sensorTask, "Sensor Task", 500, NULL, configMAX_PRIORITIES - 3, &sensorTaskHandle) == pdTRUE) {
			printf("Sensor task created\n\r");
			BSP_TSENSOR_Init();
			BSP_PSENSOR_Init();
			BSP_HSENSOR_Init();
		}
		else {
			printf("Could not create sensor task\n\r");
		}
		if(xTaskCreate(RTC_Task, "RTC Task", 500, NULL, configMAX_PRIORITIES - 2, NULL) == pdTRUE) {
			printf("RTC task created\n\r");
		}
		else {
			printf("Could not create RTC task\n\r");
		}
		//Subscribe to topics here
		//change the device name and variable name in the function call to match your Ubidots configuration
		ret = MQTTSubscribe(&client, "/v1.6/devices/rtos_grpa/ledswitch-1", QOS0, (subscribeMessageHandler));
		if (ret != MQSUCCESS) {
			printf("\n\rSubscribe failed: %ld\n\r", ret);
		}
		else {
			printf("\n\rSubscribed to topic \n\r");

			ret = MQTTYield(&client, 500);
		}
		ret = MQTTSubscribe(&client, "/v1.6/devices/rtos_grpa/autopublish", QOS0, (subscribeMessageHandler));
		if (ret != MQSUCCESS) {
			printf("\n\rSubscribe failed: %ld\n\r", ret);
		}
		else {
			printf("\n\rSubscribed to topic \n\r");

			ret = MQTTYield(&client, 500);
		}		ret = MQTTSubscribe(&client, "/v1.6/devices/rtos_grpa/tempsw", QOS0, (subscribeMessageHandler));
		if (ret != MQSUCCESS) {
			printf("\n\rSubscribe failed: %ld\n\r", ret);
		}
		else {
			printf("\n\rSubscribed to topic \n\r");

			ret = MQTTYield(&client, 500);
		}
		ret = MQTTSubscribe(&client, "/v1.6/devices/rtos_grpa/humiditysw", QOS0, (subscribeMessageHandler));
		if (ret != MQSUCCESS) {
			printf("\n\rSubscribe failed: %ld\n\r", ret);
		}
		else {
			printf("\n\rSubscribed to topic \n\r");

			ret = MQTTYield(&client, 500);
		}
		ret = MQTTSubscribe(&client, "/v1.6/devices/rtos_grpa/pressuresw", QOS0, (subscribeMessageHandler));
		if (ret != MQSUCCESS) {
			printf("\n\rSubscribe failed: %ld\n\r", ret);
		}
		else {
			printf("\n\rSubscribed to topic \n\r");

			ret = MQTTYield(&client, 500);
		}

		initCycleFinished += 1;
		printf("Starting sensor timer...\r\n\n");
		HAL_TIM_Base_Start_IT(&htim6);
		printf("Deleting Init Task\r\n\n");
		vTaskDelete(NULL);
	}
}

/*-----------------------------------------------
 * User application function
 * Creates Init task and starts ROS scheduler
-------------------------------------------------*/
void userApp() {
	printf("Starting user application\r\n\n");

	__HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
	HAL_NVIC_GetPendingIRQ(TIM6_DAC_IRQn);
	//HAL_TIM_Base_Start_IT(&htim6);

	xTaskCreate(initTask, "Init Task", 800, NULL, configMAX_PRIORITIES - 1, NULL);
	vTaskStartScheduler();

	while(1) {
	}
}

/*-------------------------------------------------
 * Function to establish connection to cloud server
 * 1. Connects to WiFi access point (AP)
 * 2. Gets date and time from network
 * 3. Connects to ubidots web server
 * 4. Connects to Ubidots MQTT broker
---------------------------------------------------*/
void brokerConnect(MQTTClient * client) {
	int32_t ret;
	//Network and MQTT variables
	device_config_t MQTT_Config;
	static unsigned char mqtt_send_buffer[MQTT_SEND_BUFFER_SIZE];
	static unsigned char mqtt_read_buffer[MQTT_READ_BUFFER_SIZE];
	net_ipaddr_t ipAddr;
	net_macaddr_t macAddr;


	//Initialise MQTT broker structure
	//Fill in this section with MQTT broker credentials from header file
	MQTT_Config.HostName = CloudBroker_HostName;
	MQTT_Config.HostPort = CloudBroker_Port;
	MQTT_Config.ConnSecurity = "0";	//plain TCP connection with no security
	MQTT_Config.MQUserName = CloudBroker_Username;
	MQTT_Config.MQUserPwd = CloudBroker_Password;
	MQTT_Config.MQClientId = CloudBroker_ClientID;

	//Initialise WiFi network
	if (net_init(&hnet, NET_IF, (wifi_net_if_init)) != NET_OK) {
		printf("\n\rError");
	}
	else {
		printf("\n\rOK");
	}
	HAL_Delay(500);

	printf("\n\rRetrieving the IP address.");

	if (net_get_ip_address(hnet, &ipAddr) != NET_OK) {
		printf("\n\rError 2");
	}
	else
	{
		switch(ipAddr.ipv) {
			case NET_IP_V4:
				printf("\n\rIP address: %d.%d.%d.%d\n\r", ipAddr.ip[12], ipAddr.ip[13], ipAddr.ip[14], ipAddr.ip[15]);
				break;
			case NET_IP_V6:
			default:
				printf("\n\rError 3");
		}
	}

	if (net_get_mac_address(hnet, &macAddr) == NET_OK) {
		printf("\n\rMac Address: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
	               macAddr.mac[0], macAddr.mac[1], macAddr.mac[2], macAddr.mac[3], macAddr.mac[4], macAddr.mac[5]);
	}

	/*
	* Fetch the epoch time from st.com and use it to set the RTC time
	*/
	if (setRTCTimeDateFromNetwork(true) != TD_OK) {
		printf("Fail setting time\r\n");
	}
	else {
		printf("Time set, Starting RTC\r\n");
		//RTC started with a 1-second wake-up interrupt
		HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 2047, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
	}

	printf("Connecting to MQTT Broker Server\r\n\n");
	//Create network socket
	ret = net_sock_create(hnet, &socket, NET_PROTO_TCP);
	if (ret != NET_OK)
	{
		printf("\n\rCould not create the socket.\r\n");
		printf("Check MQTT broker configuration settings.\r\n");
		while(1);
	}
	else
	{
		ret |= net_sock_setopt(socket, "sock_noblocking", NULL, 0);
	}

	ret = net_sock_open(socket, MQTT_Config.HostName, 1883, 0);
	if (ret != NET_OK)
	{
		printf("\n\rCould not open the socket.");
		while(1);
	}
	else {
		printf("\r\nConnected to MQTT Broker Server\r\n");
		HAL_Delay(1000);
	}

	network.my_socket = socket;
	network.mqttread = (network_rd);
	network.mqttwrite = (network_wr);

	MQTTClientInit(client, &network, MQTT_CMD_TIMEOUT, mqtt_send_buffer, MQTT_SEND_BUFFER_SIZE,
			mqtt_read_buffer, MQTT_READ_BUFFER_SIZE);

	/* MQTT connect */
	options.clientID.cstring = MQTT_Config.MQClientId;
	options.username.cstring = MQTT_Config.MQUserName;
	options.password.cstring = MQTT_Config.MQUserPwd;

	HAL_Delay(1000);

	printf("Connecting client to MQTT Broker\r\n\n");
	ret = MQTTConnect(client, &options);
	if (ret != 0)
	{
		printf("\n\rMQTTConnect() failed: %ld\n", ret);
		printf("Check MQTT client credential settings.\r\n");
		while(1);
	}
	else
	{
		printf("\n\rClient Connected to MQTT Broker\r\n");
		HAL_Delay(1000);
	}
	HAL_Delay(1000);

}
